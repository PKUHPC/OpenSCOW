/**
 * Copyright (c) 2022 Peking University and Peking University Institute for Computing and Digital Economy
 * SCOW is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *          http://license.coscl.org.cn/MulanPSL2
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

syntax = "proto3";

package scow.server;

import "google/protobuf/struct.proto";

message GetAvailablePartitionsRequest {
  option deprecated = true;
  string account_name = 1;
  string user_id = 2;
}

message Partition {
  string name = 1;
  // mem: memory size in M
  uint64 mem_mb = 2;
  // cores: number of cores
  uint32 cores = 3;
  // gpus: number of gpu
  uint32 gpus = 4;
  // nodes: number of nodes
  uint32 nodes = 5;
  // list that stores qos. the list can be empty.
  repeated string qos = 6;
  // price item description
  optional string comment = 7;
}

message ClusterPartitions {
  option deprecated = true;
  string cluster = 1;
  repeated Partition partitions = 2;
}

message GetAvailablePartitionsResponse {
  option deprecated = true;
  repeated ClusterPartitions cluster_partitions = 1;
}

message GetAvailablePartitionsForClusterRequest {
  string cluster = 1;
  string account_name = 2;
  string user_id = 3;
}

message GetAvailablePartitionsForClusterResponse {
  repeated Partition partitions = 1;
}

// get current connection state of all clusters from config files
message GetClustersConnectionInfoRequest {
}

// current connection status
// available: can access to scheduler adapter
// error: can not access to scheduler adapter
enum ClusterConnectionStatus {
  AVAILABLE = 0;
  ERROR = 1;
}

message ClusterConnectionInfo {
  string cluster_id = 1;
  ClusterConnectionStatus connection_status = 2;
  // scheduler name of cluster
  // value exisits when connectionStatus is available
  optional string scheduler_name = 3;
  // scheduler name of cluster
  // value exisits when connectionStatus is available
  repeated Partition partitions = 4;
}

message GetClustersConnectionInfoResponse {
  repeated ClusterConnectionInfo results = 1;
}

// get current clusters info from database
message GetClustersDatabaseInfoRequest {
}

enum ClusterActivationStatus {
  // status when cluster is activated
  ACTIVATED = 0;
  // status when cluster is deactivated
  DEACTIVATED = 1;
}

message ClusterDatabaseInfo {
  string cluster_id = 1;
  ClusterActivationStatus activation_status = 2;
  optional google.protobuf.Struct last_activation_operation = 3;
}

message GetClustersDatabaseInfoResponse {
  repeated ClusterDatabaseInfo results = 1;
}

message ActivateClusterRequest {
  string cluster_id = 1;
  string operator_id = 2;
}

// NOT_FOUND: cluster is not found
// FAILED_PRECONDITION: scheduler adapter can not be accessed
// ALREADY_ACTIVATED: cluster is already activated
message ActivateClusterResponse {
  bool executed = 1;
}

message DeactivateClusterRequest {
  string cluster_id = 1;
  string operator_id = 2;
  optional string deactivation_comment = 3;
}

// NOT_FOUND: cluster is not found
message DeactivateClusterResponse {
  bool executed = 1;
}

service ConfigService {

  /**
   * Depracated Notice
   * This API funcition GetAvailablePartitions has been deprecated.
   * Use the new API function GetAvailablePartitionsForCluster instead.
   */
  rpc GetAvailablePartitions(GetAvailablePartitionsRequest) returns (GetAvailablePartitionsResponse) {
    option deprecated = true;
  };

  rpc GetAvailablePartitionsForCluster(GetAvailablePartitionsForClusterRequest) returns (GetAvailablePartitionsForClusterResponse);

  rpc GetClustersConnectionInfo(GetClustersConnectionInfoRequest) returns (GetClustersConnectionInfoResponse);

  rpc GetClustersDatabaseInfo(GetClustersDatabaseInfoRequest) returns (GetClustersDatabaseInfoResponse);

  rpc ActivateCluster(ActivateClusterRequest) returns (ActivateClusterResponse);

  rpc DeactivateCluster(DeactivateClusterRequest) returns (DeactivateClusterResponse);
}
